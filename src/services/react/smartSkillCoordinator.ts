/**
 * æ™ºèƒ½æŠ€èƒ½æ‰§è¡Œåè°ƒå™¨
 * è´Ÿè´£æŒ‰é¡ºåºæ‰§è¡ŒæŠ€èƒ½ç»„ï¼Œæ¯ä¸ªæŠ€èƒ½æ‰§è¡Œå‰è¿›è¡Œå‚æ•°ç¡®è®¤
 */

import type { Scenario, Task } from '../../types'
import { useTaskStore } from '../../stores/taskStore'
import { useScheduleStore } from '../../stores/scheduleStore'
import { useMessageStore } from '../../stores/messageStore'

interface SkillExecutionContext {
  scenario: Scenario
  scheduleId: string
  // userInput: string,
  extractedParams: Record<string, any>
}

interface SkillExecutionResult {
  success: boolean
  taskId: string
  skillCode: string
  message: string
  nextAction?: 'continue' | 'confirm' | 'complete'
  confirmMessage?: string
}

export class SmartSkillCoordinator {
  private taskStore = useTaskStore()
  private scheduleStore = useScheduleStore()
  private messageStore = useMessageStore()

  /**
   * æ‰§è¡Œåœºæ™¯æŠ€èƒ½ç»„
   */
  async executeScenarioSkills(context: SkillExecutionContext): Promise<{
    success: boolean
    executedSkills: SkillExecutionResult[]
    finalMessage: string
  }> {
    const { scenario, scheduleId, /* userInput, */ extractedParams } = context
    const executedSkills: SkillExecutionResult[] = []
    
    console.log(`[SmartCoordinator] å¼€å§‹æ‰§è¡Œåœºæ™¯: ${scenario.name}`, {
      scheduleId,
      skillCount: scenario.skills.length
    })

    // ä¸ºæ¯ä¸ªæŠ€èƒ½åˆ›å»ºä»»åŠ¡
    const tasks = this.createSkillTasks(scenario, scheduleId)
    this.taskStore.addTasks(tasks)

    // é€ä¸ªæ‰§è¡ŒæŠ€èƒ½
    for (const task of tasks) {
      try {
        const result = await this.executeSingleSkill(task, /* userInput, */ extractedParams)
        executedSkills.push(result)
        
        // å‘é€æ‰§è¡Œç»“æœæ¶ˆæ¯
        this.messageStore.addSystemMessage(result.message)
        
        // å¦‚æœéœ€è¦ç¡®è®¤ï¼Œæš‚åœæ‰§è¡Œ
        if (result.nextAction === 'confirm' && result.confirmMessage) {
          this.messageStore.addSystemMessage(result.confirmMessage)
          // è¿™é‡Œåº”è¯¥è§¦å‘ç”¨æˆ·ç¡®è®¤æµç¨‹
          break
        }
        
      } catch (error) {
        console.error(`[SmartCoordinator] æŠ€èƒ½æ‰§è¡Œå¤±è´¥: ${task.skill}`, error)
        executedSkills.push({
          success: false,
          taskId: task.id,
          skillCode: task.skill,
          message: `âŒ æŠ€èƒ½"${task.title}"æ‰§è¡Œå¤±è´¥: ${(error as Error).message}`
        })
      }
    }

    const allSuccess = executedSkills.every(r => r.success)
    const finalMessage = allSuccess 
      ? `âœ… ${scenario.name}åœºæ™¯çš„æ‰€æœ‰æŠ€èƒ½å·²æˆåŠŸæ‰§è¡Œ`
      : `âš ï¸ ${scenario.name}åœºæ™¯éƒ¨åˆ†æŠ€èƒ½æ‰§è¡Œå®Œæˆ`

    return {
      success: allSuccess,
      executedSkills,
      finalMessage
    }
  }

  /**
   * åˆ›å»ºæŠ€èƒ½ä»»åŠ¡åˆ—è¡¨
   */
  private createSkillTasks(scenario: Scenario, scheduleId: string): Task[] {
    return scenario.skills.map((skillCode, index) => ({
      id: `auto-task-${scheduleId}-${skillCode}-${Date.now()}-${index}`,
      scheduleId,
      title: this.getSkillDisplayName(skillCode),
      desc: this.getSkillDescription(skillCode),
      icon: this.getSkillIcon(skillCode),
      skill: skillCode,
      actionBtn: 'æ‰§è¡Œ',
      date: new Date().toISOString().split('T')[0] || new Date().toLocaleDateString('sv-SE'),
      status: 'pending' as const,
      meta: {
        autoGenerated: true,
        executionOrder: index,
        scenarioCode: scenario.code
      }
    }))
  }

  /**
   * æ‰§è¡Œå•ä¸ªæŠ€èƒ½
   */
  private async executeSingleSkill(
    task: Task,
    // userInput: string,
    extractedParams: Record<string, any>
  ): Promise<SkillExecutionResult> {
    console.log(`[SmartCoordinator] æ‰§è¡ŒæŠ€èƒ½: ${task.skill}`, { taskId: task.id })
    
    try {
      // æ£€æŸ¥æ˜¯å¦éœ€è¦å‚æ•°ç¡®è®¤
      const paramCheck = this.checkRequiredParameters(task.skill, extractedParams)
      
      if (!paramCheck.ready) {
        return {
          success: true,
          taskId: task.id,
          skillCode: task.skill,
          message: `ğŸ” æŠ€èƒ½"${task.title}"éœ€è¦ç¡®è®¤å‚æ•°: ${paramCheck.missingParams.join(', ')}`,
          nextAction: 'confirm',
          confirmMessage: this.generateParameterConfirmation(task, paramCheck.missingParams)
        }
      }

      // æ‰§è¡ŒæŠ€èƒ½ï¼ˆè¿™é‡Œåº”è¯¥è°ƒç”¨å®é™…çš„æŠ€èƒ½æ‰§è¡Œé€»è¾‘ï¼‰
      const executionResult = await this.invokeSkill(task.skill, extractedParams)
      
      // æ›´æ–°ä»»åŠ¡çŠ¶æ€
      this.taskStore.updateTaskStatus(task.id, 'done')
      
      return {
        success: executionResult.success,
        taskId: task.id,
        skillCode: task.skill,
        message: executionResult.message
      }
      
    } catch (error) {
      this.taskStore.updateTaskStatus(task.id, 'pending')
      throw error
    }
  }

  /**
   * æ£€æŸ¥æ‰€éœ€å‚æ•°
   */
  private checkRequiredParameters(
    skillCode: string,
    availableParams: Record<string, any>
  ): { ready: boolean; missingParams: string[] } {
    const requiredParamsMap: Record<string, string[]> = {
      'book_meeting_room': ['location', 'date', 'startTime'],
      'notify_attendees': ['attendees', 'date', 'startTime'],
      'arrange_transport': ['from', 'to', 'date'],
      'check_hotel': ['to', 'date']
    }

    const requiredParams = requiredParamsMap[skillCode] || []
    const missingParams = requiredParams.filter(param => 
      !availableParams[param] || availableParams[param] === ''
    )

    return {
      ready: missingParams.length === 0,
      missingParams
    }
  }

  /**
   * ç”Ÿæˆå‚æ•°ç¡®è®¤æ¶ˆæ¯
   */
  private generateParameterConfirmation(task: Task, missingParams: string[]): string {
    const paramNames: Record<string, string> = {
      'location': 'åœ°ç‚¹',
      'date': 'æ—¥æœŸ',
      'startTime': 'å¼€å§‹æ—¶é—´',
      'attendees': 'å‚ä¼šäººå‘˜',
      'from': 'å‡ºå‘åœ°',
      'to': 'ç›®çš„åœ°'
    }

    const missingNames = missingParams.map(p => paramNames[p] || p)
    
    return `è¯·ç¡®è®¤${task.title}çš„${missingNames.join('å’Œ')}ä¿¡æ¯`
  }

  /**
   * è°ƒç”¨æŠ€èƒ½æ‰§è¡Œ
   * é€šè¿‡ä¼ ç»Ÿ skillRegistry æ‰§è¡ŒçœŸå®æŠ€èƒ½é€»è¾‘
   */
  private async invokeSkill(
    skillCode: string,
    params: Record<string, any>
  ): Promise<{ success: boolean; message: string }> {
    try {
      // ä½¿ç”¨ä¼ ç»Ÿæ¨¡å¼çš„ executeSkill æ‰§è¡ŒçœŸå®æŠ€èƒ½
      const { executeSkill } = await import('../traditional/skillRegistry')
      
      // ä»å‚æ•°æˆ–ä¸Šä¸‹æ–‡æ„å»º schedule å¯¹è±¡ç”¨äºæŠ€èƒ½æ‰§è¡Œ
      const scheduleId = params.scheduleId || ''
      const schedule = scheduleId ? this.scheduleStore.getSchedule(scheduleId) : null
      
      if (schedule) {
        const result = await executeSkill(skillCode, schedule)
        return {
          success: true,
          message: result.text 
            ? `âœ… æŠ€èƒ½"${this.getSkillDisplayName(skillCode)}"æ‰§è¡ŒæˆåŠŸ: ${result.text}`
            : `âœ… æŠ€èƒ½"${this.getSkillDisplayName(skillCode)}"æ‰§è¡ŒæˆåŠŸ`
        }
      }
      
      // æ— æ³•æ‰¾åˆ°å…³è”æ—¥ç¨‹ï¼Œè¿”å›éœ€è¦æ›´å¤šä¿¡æ¯
      return {
        success: false,
        message: `âš ï¸ æŠ€èƒ½"${this.getSkillDisplayName(skillCode)}"æ‰§è¡Œå¤±è´¥: æœªæ‰¾åˆ°å…³è”æ—¥ç¨‹`
      }
    } catch (error) {
      return {
        success: false,
        message: `âŒ æŠ€èƒ½"${this.getSkillDisplayName(skillCode)}"æ‰§è¡Œå‡ºé”™: ${(error as Error).message}`
      }
    }
  }

  // è¾…åŠ©æ–¹æ³•
  private getSkillDisplayName(skillCode: string): string {
    const names: Record<string, string> = {
      'book_meeting_room': 'é¢„è®¢ä¼šè®®å®¤',
      'notify_attendees': 'é€šçŸ¥å‚ä¼šäºº',
      'arrange_transport': 'äº¤é€šå®‰æ’',
      'check_hotel': 'é¢„è®¢é…’åº—',
      'search_contacts': 'é€šè®¯å½•æŸ¥è¯¢',
      'apply_trip': 'å‡ºå·®ç”³è¯·'
    }
    return names[skillCode] || skillCode
  }

  private getSkillDescription(skillCode: string): string {
    const descriptions: Record<string, string> = {
      'book_meeting_room': 'æ™ºèƒ½é¢„è®¢åˆé€‚çš„ä¼šè®®å®¤',
      'notify_attendees': 'å‘å‚ä¼šäººå‘˜å‘é€ä¼šè®®é‚€è¯·',
      'arrange_transport': 'è§„åˆ’æœ€ä¼˜å‡ºè¡Œè·¯çº¿',
      'check_hotel': 'æŸ¥æ‰¾å¹¶é¢„è®¢åˆé€‚é…’åº—',
      'search_contacts': 'æŸ¥è¯¢è”ç³»äººä¿¡æ¯',
      'apply_trip': 'æäº¤å‡ºå·®ç”³è¯·æµç¨‹'
    }
    return descriptions[skillCode] || ''
  }

  private getSkillIcon(skillCode: string): string {
    const icons: Record<string, string> = {
      'book_meeting_room': 'fa-door-open',
      'notify_attendees': 'fa-envelope',
      'arrange_transport': 'fa-car',
      'check_hotel': 'fa-hotel',
      'search_contacts': 'fa-address-book',
      'apply_trip': 'fa-file-contract'
    }
    return icons[skillCode] || 'fa-cube'
  }
}